const registry = {}
const rootwire = _link('sub', { prefix: [], local: { 'sub': [] } })

module.exports = rootwire

function ispojo (x) { return x && !Array.isArray(x) && typeof x === 'object' }
function verify (label) {
  return (typeof label === 'string') && /^[a-zA-Z0-9\-\_]+$/g.test(label)
}
function _link (sublabel, internals, init) {
  return function wire (superlabel) {
    if (!verify(superlabel)) throw new Error('name contains illegal characters')
    if (init) throw new Error(`already initialized as "${superlabel}"`)
    init = superlabel
    // internals.local[sublabel] = []
    return _wire(sublabel, superlabel, internals)
  }
}
function _wire (sublabel, superlabel, internals, init) {
  const { prefix, local: parent } = internals
  const local = {}
  return function register (name) {
    if (!verify(name)) throw new Error('name contains illegal characters')
    if (init)  throw new Error(`already initialized as "${name}"`)
    init = name
    const F = parent[sublabel]
    local[superlabel] = `/${prefix.join('/')}`
    const path = [...prefix, name]
    const id = `/${path.join('/')}`
    parent[sublabel] = id
    for (var i = 0, len = F.length; i < len; i++) F[i](id)
    const internals = { prefix: path, local }
    return _register(internals)
  }
}
function _register (internals) {
  const { prefix, local } = internals
  const id = prefix.join('/')
  const protocol = { id, signals: { to, from }, link }
  return registry[id] = protocol
  function link (sublabel) {
    if (!verify(sublabel)) throw new Error('label contains illegal characters')
    if (local[sublabel]) throw new Error('label taken')
    local[sublabel] = []
    return _link(sublabel, internals)
  }
  function from (pattern, fn) { return _from(internals, pattern, fn) }
  function to (pattern, fn) { return _to(internals, pattern, fn) }
}
// ------------------------------------------------------------------
function realname (name, local /**/, real, done, fail) {
  // @TODO: maybe add timeout to track non-ready peers

  real = local[name]
  // if "name"
  if (typeof real !== 'string') real.push(name => done(name))
  else done(real)
  return new Promise((done, fail) => (done = ok, fail = ko))
}
// ------------------------------------------------------------------
async function _from (internals, pattern, fn) {
  if (verify(pattern) || typeof pattern === 'function') pattern = { name: pattern }
  else if (Array.isArray(pattern)) {
    const [name, type] = pattern
    pattern = {}
    if (verify(name) || typeof name === 'function') pattern.from = name
    if (verify(type) || typeof type === 'function') pattern.from = type
  }
  if (ispojo(pattern)) {
    return typeof fn === 'function' ? next(fn) : next
    async function next (listener) {
      if (!listener) return off()
      if (typeof listener !== 'function') throw new Error('listener must be a function')
      await on(use(pattern, listener))
      return off
      // @TODO: maybe remove `off()` and do it only on calling `next()` empty
      function off () { /* @TODO: unregister */ }
      function on (forward) {

        // @TODO: maybe allow async patterns, but with TIMEOUTs
        // @TODO: store `forward` fn until `off()` is called
        // forward(message) // if pattern matches
        // @TODO: replace `handlersA` with correct namespace

        // @NOTE: pushes 'name' and waits until 'realname' is known
        // sending messages to 'name' looks up 'realname'
        // => sends to 'realname'
        // => every 'realname' has associated listeners
        const real = await realname(name, internals.local)
        handlersA[`${real}/${type}`] = fn
      }
    }
  }
  else throw new Error('pattern must be: <from> or [<from>, <type>] or fn or { ...<msg> } (where <X> = str | fn)')
}

// ------------------------------------------------------------------
async function _to (internals, name, type, msg) {
  if (ispojo(name)) [name, type, fn] = ['*', '*', name]
  if (typeof name !== 'string') throw new Error('`name` must be string')
  if (typeof type === 'function') [type, fn] = ['*', type]
  if (!type) return (type, fn) => _to(internals, name, type, fn)
  if (typeof type !== 'string') throw new Error('`type` must be string')
  if (!fn) return fn => _to(internals, name, type, fn)
  if (typeof fn !== 'function') throw new Error('`fn` must be a function')

  // @NOTE: problem if super did not yet call `from()`

  // @TODO: increase message counter
  // @TODO: replace `handlersA` with correct namespace
  const real = await realname(name, internals.local)
  const handler = handlersA[`${real}/${type}`]



  // message.to = name
  // const { to } = message
  // const sendTo = handlersA[to]
  // if (sendTo) sendTo(message)

  return message.id
}
// ------------------------------------------------------------------
// @NOTE: maybe adapt message format
// const message = { flow: [id, from, to], refs, type, data }
// const pattern = { from, refs, type, data }
const matchFrom = (test, from) => typeof test === 'function' ? test(from) : from === test
const matchRefs = (test, refs) => typeof test === 'function' ? test(refs) : refs.filter(id => test.contains(id)).length === test.length
const matchType = (test, type) => typeof test === 'function' ? test(type) : type === test
const matchData = (test, data) => {
  if (typeof test === 'function') {
    try { return !!test(data) }
    catch (e) { return }
  } else {
    if (data === test) return true
    try { return JSON.stringify(data) === JSON.stringify(test) }
    catch (e) { return }
  }
}
function use (pattern = {}, handle) {
  if (typeof pattern === 'function') return function forward (message) {
    try { if (pattern(message)) handle(message) }
    catch (e) { return }
  }
  return function forward (message) {
    const { from, refs, type, data } = message
    try {
      if ('from' in pattern && !matchFrom(pattern.from, from)) return
      if ('refs' in pattern && !matchRefs(pattern.refs, refs)) return
      if ('type' in pattern && !matchType(pattern.type, type)) return
      if ('data' in pattern && !matchData(pattern.data, data)) return
      handle(message)  
    } catch (e) { return }
  }
}
