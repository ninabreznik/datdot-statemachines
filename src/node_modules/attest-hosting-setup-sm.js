const XState = require('xstate')
const { Machine, assign, spawn, send, sendParent } = XState

module.exports = Machine(
  {
    initial: 'connect_to_encoders_and_hosters',
    context: {
      retry: 0
    },
    states: {
      connect_to_encoders_and_hosters: {
        invoke: [
          {
            id: 'connect1', src: 'connect_to_encoders',  
            onDone: {
              actions: [
                (context, event) => console.log(event.data),
              ] 
            },
            onError: {
              target: 'fail_connect_to_encoders_and_hosters',
            }
          },
          {
            id: 'connect2', src: 'connect_to_hosters',
            onDone: {
              target: 'get_encoders_and_hosters_states',
              actions: [
                (context, event) => console.log(event.data),
                sendParent('Connected')
              ] 
            },
            onError: {
              target: 'fail_connect_to_encoders_and_hosters',
            }
          },
        ]
      },
      get_encoders_and_hosters_states: {
        invoke: {
          id: 'get_states', src: 'get_last_saved_states',
          onDone: {
            target: 'data_from_encoders_to_hosters',
            actions: [
              (context, event) => console.log(event.data),
              sendParent('Got state')
            ] 
          },
          onError: {
            target: 'fail_get_encoders_and_hosters_states',
          },
        },
        on: {
          RESOLVE: {
            target: 'data_from_encoders_to_hosters',
            actions: (context, event) => console.log('Resolving now')
          },
          REJECT: { target: 'fail_get_encoders_and_hosters_states' }
        }
      },
      data_from_encoders_to_hosters: {
        invoke: {
          id: 'continue_setup', src: 'data_from_encoders_to_hosters',
          // id: 'disconnect', src: 'disconnect',
          onDone: {
            target: 'submit_report',
                        actions: [
              (context, event) => console.log(event.data),
              sendParent('Received and sent data')
            ] 
          },
          onError: {
            target: 'fail_data_from_encoders_to_hosters',
          }      
        }
      },
      submit_report: {
        invoke: {
          id: 'send_report', src: 'send_report_to_chain',
          onDone: {
            target: 'final',
                        actions: [
              (context, event) => console.log(event.data),
              sendParent('Sent report')
            ] 
          },
          onError: {
            target: 'fail_submit_report',
          }
        }
      },
      fail_connect_to_encoders_and_hosters: {
        on: {
          _RETRY: {
            target: 'connect_to_encoders_and_hosters',
            actions: assign((context) => {
              return {
                ...context,
                retry: context.retry + 1
              }
            }),
          }, 
          _EXIT: {
            target: 'final',
            actions: assign((context) => {
              return {
                ...this.context,
                retry: 0
              }
            }),            
          }
        }
      },
      fail_get_encoders_and_hosters_states: {
        on: {
          _RETRY: {
            target: 'get_encoders_and_hosters_states',
            actions: assign((context) => {
              return {
                ...context,
                retry: context.retry + 1
              }
            }),
          }, 
          _EXIT: {
            target: 'final',
            actions: assign((context) => {
              return {
                ...this.context,
                retry: 0
              }
            }),            
          }
        }
      },
      fail_data_from_encoders_to_hosters: {
        on: {
          _RETRY: {
            target: 'data_from_encoders_to_hosters',
            actions: assign((context) => {
              return {
                ...context,
                retry: context.retry + 1
              }
            }),
          }, 
          _EXIT: {
            target: 'final',
            actions: assign((context) => {
              return {
                ...this.context,
                retry: 0
              }
            }),            
          }
        }
      },
      fail_submit_report: { 
        on: {
          _RETRY: {
            target: 'submit_report',
            actions: assign((context) => {
              return {
                ...context,
                retry: context.retry + 1
              }
            }),
          }, 
          _EXIT: {
            target: 'final',
            actions: assign((context) => {
              return {
                ...this.context,
                retry: 0
              }
            }),            
          }
        }
      },
      final: {
        type: 'final',
      },
    },
  },
  {
    services: {
      connect_to_encoders: new Promise((resolve, reject) => { setTimeout(() => { resolve('connected to encoders') }, 3000) }),
      connect_to_hosters: new Promise((resolve, reject) => { setTimeout(() => { resolve('connected to hosters') }, 3000) }),
      get_last_saved_states: new Promise((resolve, reject) => { setTimeout(() => { resolve('got states') }, 3000) }),
      data_from_encoders_to_hosters: new Promise((resolve, reject) => { setTimeout(() => { resolve('sent data from encoders to hosters') }, 3000) }),
      disconnect: new Promise((resolve, reject) => { setTimeout(() => { resolve('disconnected') }, 3000) }),
      send_report_to_chain: new Promise((resolve, reject) => { setTimeout(() => { resolve('report sent') }, 3000) }),
    }
  }
)
