const XState = require('xstate')
const { Machine, assign, spawn, send, sendParent } = XState

const is_mismatch = (context, event) => {
  console.log({context})
  return context.data.includes('mismatch')
}

module.exports = Machine({
  initial:'connecting',
  context: {
    data: ''
  },
  states: {
    connecting: {
      invoke: {
        id: 'connect', src: 'join_attestors_swarm',
        onDone: {
          target: 'randomizing',
          actions: (context, event) => console.log('attest-sm:', event.data)
        },
        onError: {
          target: 'finish',
          actions: (context, event) => console.log('attest-sm:', event.data)
        }
      },
    },
    randomizing: {
      invoke: {
        id: 'randomize', src: 'random_number_procedure',
        onDone: {
          target: 'idle',
          actions: (context, event) => console.log('attest-setup-sm:', event.data)
        },
        onError: {
          target: 'disconnecting',
          actions: (context, event) => console.log('attest-setup-sm:', event.data)
        }
      },
    },
    idle: {
      id: 'idle',
      entry: () => console.log('attest-sm: idle_state') ,
      on: {
        SWARM_CHECK: {
          target: 'performance_check'
        },
        REPORT_REVIEW: { 
          // hyperfeed update
          target: 'reviewing'
        },
        FINISH: {
          target: 'finish'
        }
      },
    },
    reviewing: {
      invoke: {
        id: 'review', src: 'reviewing_lead_attestors_reports',
        onDone: {
          target: 'evaluating',
          actions: assign((context, event) => { 
            console.log('attest-performance-sm:', event.data)
            return { ...context, data: event.data } 
          })
        },
        onError: {
          target: 'idle',
          actions: (context, event) => console.log('attest-performance-sm:', event.data)
        }
      },
    },
    evaluating: {
      always: [
        { target: 'disputing', cond: is_mismatch },
        { target: 'idle', cond: !is_mismatch }
      ],
    },
    performance_check: {
      invoke: {
        id: 'check', src: 'check_performance_for_selected_chunks',
        onDone: {
          target: 'reporting',
          actions: (context, event) => console.log('attest-performance-sm:', event.data)
        },
        onError: {
          target: 'idle',
          actions: (context, event) => console.log('attest-performance-sm:', event.data)
        }
      },
    },
    reporting: {
      invoke: {
        id: 'report', src: 'report_performance_to_chain',
        onDone: {
          target: 'idle',
          actions: (context, event) => console.log('attest-performance-sm:', event.data)
        },
        onError: {
          target: 'idle',
          actions: (context, event) => console.log('attest-performance-sm:', event.data)
        }
      },
    },
    disputing: {
      invoke: {
        id: 'dispute', src: 'notify_chain_about_mismatch',
        onDone: {
          target: 'idle',
          actions: (context, event) => console.log('attest-performance-sm:', event.data)
        },
        onError: {
          target: 'disconnecting',
          actions: (context, event) => console.log('attest-performance-sm:', event.data)
        }
      },
    },
    disconnecting: {
      invoke: {
        id: 'disconnect', src: 'disconnect',
        onDone: {
          target: 'finish',
          actions: (context, event) => console.log('attest-sm:', event.data)
        },
        onError: {
          target: 'finish',
          actions: (context, event) => console.log('attest-sm:', event.data)
        }
      },
    },
    finish: {
      type: 'final',
      data: {type: 'finished'}
    },
  }
},
{
  services: {
    join_attestors_swarm: new Promise((resolve, reject) => { setTimeout(() => { resolve('joined') }, 3000) }),
    random_number_procedure: new Promise((resolve, reject) => { setTimeout(() => { resolve('randomized') }, 3000) }),
    reviewing_lead_attestors_reports: new Promise((resolve, reject) => { setTimeout(() => { resolve('mismatch') }, 3000) }),
    notify_chain_about_mismatch: new Promise((resolve, reject) => { setTimeout(() => { resolve('notified') }, 3000) }),
    check_performance_for_selected_chunks: new Promise((resolve, reject) => { setTimeout(() => { resolve('checked') }, 3000) }),
    report_performance_to_chain: new Promise((resolve, reject) => { setTimeout(() => { resolve('reported') }, 3000) }),
  },
})
