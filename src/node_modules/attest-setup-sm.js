const XState = require('xstate')
const { Machine, assign, spawn, send, sendParent } = XState

module.exports = Machine({
  initial: 'connecting',
  states: {
    connecting: {
      invoke: {
        id: 'connect', src: 'connect_to_encoders_and_hosters',
        onDone: {
          target: 'syncing',
          actions: (_, event) => console.log('attest-setup-sm:', event.data)
        },
        onError: {
          target: 'reporting',
          actions: (_, event) => console.log('attest-setup-sm:', event.data)
        }
      },
    },
    syncing: {
      invoke: {
        id: 'sync', src: 'get_last_saved_states',
        onDone: {
          target: 'verifying',
          actions: (_, event) => console.log('attest-setup-sm:', event.data)
        },
        onError: {
          target: 'reporting',
          actions: (_, event) => console.log('attest-setup-sm:', event.data)
        }
      },
    },
    verifying: {
      invoke: {
        id: 'verifying', src: 'get_data_and_forward_to_hoster',
        onDone: {
          target: 'reporting',
          actions: (_, event) => console.log('attest-setup-sm:', event.data)
        },
        onError: {
          target: 'reporting',
          actions: (_, event) => console.log('attest-setup-sm:', event.data)
        }      
      }
    },
    reporting: {
      invoke: {
        id: 'reporting', src: 'send_report_to_chain',
        onDone: {
          target: 'disconnecting',
          actions: (_, event) => console.log('attest-setup-sm:', event.data)
        },
        onError: {
          target: 'finish',
          actions: (_, event) => console.log('attest-setup-sm:', event.data)
        }
      }
    },
    disconnecting: {
      invoke: {
        id: 'disconnect', src: 'disconnect',
        onDone: {
          target: 'finish',
          actions: (_, event) => console.log('attest-setup-sm:', event.data)
        },
        onError: {
          target: 'reporting',
          actions: (_, event) => console.log('attest-setup-sm:', event.data)
        }
      },
    },
    finish: {
      type: 'final',
      data: {type: 'finished'}
    },
  },
},
{
  services: {
    connect_to_encoders_and_hosters: new Promise((resolve, reject) => { setTimeout(() => { resolve('connected') }, 3000) }),
    get_last_saved_states: new Promise((resolve, reject) => { setTimeout(() => { resolve('synced') }, 3000) }),
    get_data_and_forward_to_hoster: new Promise((resolve, reject) => { setTimeout(() => { resolve('verified') }, 3000) }),
    send_report_to_chain: new Promise((resolve, reject) => { setTimeout(() => { resolve('reported') }, 3000) }),
    disconnect: new Promise((resolve, reject) => { setTimeout(() => { resolve('disconnected') }, 3000) })
  },
})
