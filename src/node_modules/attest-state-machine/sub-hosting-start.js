module.exports = {
  initial: 'connect_to_encoders_and_hosters',
  states: {
    connect_to_encoders_and_hosters: {
      entry: ['connect_to_encoders', 'connect_to_hosters'],
      on: {
       RESOLVE: 'get_encoders_and_hosters_states',
       REJECT: 'fail_connect_to_encoders_and_hosters' // track who failed, to know who should reconnect in retry
      }
    },
    get_encoders_and_hosters_states: {
      entry: ['get_encoders_and_hosters_last_saved_state'],
      on: {
        RESOLVE: 'data_from_encoders_to_hosters',
        REJECT: 'fail_get_encoders_and_hosters_states' // track who failed, to know who should retry (and to respond to chain if it fails again)
      }
    },
    data_from_encoders_to_hosters: {
      entry: ['get_missing_encoded_data_compare_and_forward_to_hosters'],
      exit: ['disconnect'],
      on: {
        RESOLVE: 'submit_report',
        REJECT: 'fail_data_from_encoders_to_hosters' // track who failed, to know who should retry (and to respond to chain if it fails again)
      }
    },
    submit_report: {
      entry: ['send_report_to_chain'],
      on: {
        _RESOLVE: '#idleState',
        _REJECT: 'fail_submit_report'
      }
    },
    fail_connect_to_encoders_and_hosters: {
      on: {
        _RETRY: 'connect_to_encoders_and_hosters'
      }
    },
    fail_get_encoders_and_hosters_states: {
      on: {
        _RETRY: 'get_encoders_and_hosters_states'
      }
    },
    fail_data_from_encoders_to_hosters: {
      on: {
        _RETRY: 'data_from_encoders_to_hosters'
      }
    },
    fail_submit_report: {
      on: {
        _RETRY: 'submit_report'
      }
    },
  }
}
