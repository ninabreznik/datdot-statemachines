const XState = require('xstate')
const { Machine, assign, spawn, send, sendParent } = XState

const retryLessThan3 = (context, event) => {
  return context.retry < 3
}

module.exports = Machine({
  initial: 'connecting',
  context: {
    retry: 0
  },
  states: {
    connecting: {
      invoke: {
        id: 'connect', src: 'connect_to_attestor',
        onDone: {
          target: 'syncing',
          actions: assign((context, event) => { 
            console.log(event.data)
            return { ...context, retry: 0 } 
          }),
        },
        onError: {
          target: 'connecting', 
          cond: retryLessThan3,
          target: 'fail',
          actions: assign((context) => { return { ...context, retry: context.retry + 1 } }),
        }
      },
    },
    syncing: {
      invoke: {
        id: 'sync', src: 'get_last_saved_state',
        onDone: {
          target: 'encoding',
          actions: assign((context, event) => { 
            console.log(event.data)
            return { ...context, retry: 0 } 
          }),
        },
        onError: {
          target: 'syncing', 
          cond: retryLessThan3,
          target: 'fail',
          actions: assign((context) => { return { ...context, retry: context.retry + 1 } }),
        }
      },
    },
    encoding: {
      invoke: {
        id: 'sync', src: 'encode_and_send_to_attestor',
        onDone: {
          target: 'finish',
          actions: assign((context, event) => { 
            console.log(event.data)
            return { ...context, retry: 0 } 
          }),
        },
        onError: {
          target: 'encoding', 
          cond: retryLessThan3,
          target: 'fail',
          actions: assign((context) => { return { ...context, retry: context.retry + 1 } }),
        }
      },
    },
    finish: {
      type: 'final',
      data: {type: 'finished'}
    },
    finish: {
      type: 'final',
      data: {type: 'finished'}
    }
  },
},
{
  services: {
    connect_to_attestor: new Promise((resolve, reject) => { setTimeout(() => { resolve('connected') }, 3000) }),
    get_last_saved_state: new Promise((resolve, reject) => { setTimeout(() => { resolve('synced') }, 3000) }),
    encode_and_send_to_attestor: new Promise((resolve, reject) => { setTimeout(() => { resolve('encoded') }, 3000) }),
  },
})
