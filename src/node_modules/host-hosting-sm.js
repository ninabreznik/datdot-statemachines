const XState = require('xstate')
const { Machine, assign, spawn, send, sendParent } = XState

const retryLessThan3 = (context, event) => {
  return context.retry < 3
}

module.exports = Machine({
  initial: 'connecting',
  context: {
    retry: 0
  },
  states: {
    connecting: {
      invoke: {
        id: 'connect', src: 'connect_to_attestor',
        onDone: {
          target: 'syncing',
          actions: assign((context, event) => { 
            console.log(event.data)
            return { ...context, retry: 0 } 
          }),
        },
        onError: {
          target: 'connecting', 
          cond: retryLessThan3,
          target: 'fail',
          actions: assign((context) => { return { ...context, retry: context.retry + 1 } }),
        }
      },
    },
    syncing: {
      invoke: {
        id: 'sync', src: 'get_last_saved_state',
        onDone: {
          target: 'storing',
          actions: assign((context, event) => { 
            console.log(event.data)
            return { ...context, retry: 0 } 
          }),
        },
        onError: {
          target: 'syncing', 
          cond: retryLessThan3,
          target: 'fail',
          actions: assign((context) => { return { ...context, retry: context.retry + 1 } }),
        }
      },
    },
    storing: {
      invoke: {
        id: 'sync', src: 'receive_and_store_data_from_attestor',
        onDone: {
          target: 'hosting',
          actions: assign((context, event) => { 
            console.log(event.data)
            return { ...context, retry: 0 } 
          }),
        },
        onError: {
          target: 'storing', 
          cond: retryLessThan3,
          target: 'fail',
          actions: assign((context) => { return { ...context, retry: context.retry + 1 } }),
        }
      },
    },
    hosting: {
      id: 'hosting',
      on: {
        PERFORMANCE_CHECK: {
          target: 'reporting_performance',
        },
        STORAGE_CHECK: {
          target: 'providing_storage_proofs',
        },
        HOSTING_PAUSE: {
          target: 'pausing',
        },
        HOSTING_RESUME: {
          target: 'resuming',
        },
        HOSTING_END: {
          target: 'ending',
        },
      },
    },
    providing_storage_proofs: {
      initial: 'connecting',
      states: {
        connecting: {
          invoke: {
            id: 'connect_to_provide_proof', src: 'connect_to_attestor',
            onDone: {
              target: 'sending_proofs',
              actions: assign((context, event) => { 
                console.log(event.data)
                return { ...context, retry: 0 } 
              }),
            },
            onError: {
              target: 'connecting', 
              cond: retryLessThan3,
              target: '#hosting',
              actions: assign((context) => { return { ...context, retry: context.retry + 1 } }),
            }
          }
        },
        sending_proofs: {
          invoke: {
            id: 'proof', src: 'send_proofs',
            onDone: {
              target: '#hosting',
              actions: assign((context, event) => { 
                console.log(event.data)
                return { ...context, retry: 0 } 
              }),
            },
            onError: {
              target: 'sending_proofs', 
              cond: retryLessThan3,
              target: '#hosting',
              actions: assign((context) => { return { ...context, retry: context.retry + 1 } }),
            }
          }
        }
      }
    },
    reporting_performance: {
      initial: 'connecting',
      states: {
        connecting: {
          invoke: {
            id: 'connect_to_lead_attestors', src: 'connect_to_lead_attestors',
            onDone: {
              target: 'sending_reports',
              actions: assign((context, event) => { 
                console.log(event.data)
                return { ...context, retry: 0 } 
              }),
            },
            onError: {
              target: 'connecting', 
              cond: retryLessThan3,
              target: '#hosting',
              actions: assign((context) => { return { ...context, retry: context.retry + 1 } }),
            }
          }
        },
        sending_reports: {
          invoke: {
            id: 'report', src: 'report_about_swarm_activity',
            onDone: {
              target: '#hosting',
              actions: assign((context, event) => { 
                console.log(event.data)
                return { ...context, retry: 0 } 
              }),
            },
            onError: {
              target: 'sending_reports', 
              cond: retryLessThan3,
              target: '#hosting',
              actions: assign((context) => { return { ...context, retry: context.retry + 1 } }),
            }
          }
        }
      }
    },
    pausing: {
      invoke: {
        id: 'pause', src: 'leave_swarm',
        onDone: {
          target: 'reporting',
          actions: assign((context, event) => { 
            console.log(event.data)
            return { ...context, retry: 0 } 
          }),
        },
        onError: {
          target: 'pausing', 
          cond: retryLessThan3,
          target: 'reporting',
          actions: assign((context) => { return { ...context, retry: context.retry + 1 } }),
        }
      },
    },
    resuming: {
      invoke: {
        id: 'resume', src: 'join_swarm',
        onDone: {
          target: 'reporting',
          actions: assign((context, event) => { 
            console.log(event.data)
            return { ...context, retry: 0 } 
          }),
        },
        onError: {
          target: 'resuming', 
          cond: retryLessThan3,
          target: 'reporting',
          actions: assign((context) => { return { ...context, retry: context.retry + 1 } }),
        }
      },
    },
    ending: {
      invoke: {
        id: 'end', src: 'delete_data_and_leave_swarm',
        onDone: {
          target: 'finish',
          actions: assign((context, event) => { 
            console.log(event.data)
            return { ...context, retry: 0 } 
          }),
        },
        onError: {
          // TODO
          // what happens if you fail to end hosting
          // should you leave hosting state and we add onExit: endHosting?
          // or do we run a cleanup of all unsuccessful things 
          // every once in a while?
          target: 'ending', 
          cond: retryLessThan3,
          target: 'fail',
          actions: assign((context) => { return { ...context, retry: context.retry + 1 } }),
        }
      },
    },
    reporting: {
      invoke: {
        id: 'report', src: 'report_to_chain',
        onDone: {
          target: '#hosting',
          actions: assign((context, event) => { 
            console.log(event.data)
            return { ...context, retry: 0 } 
          }),
        },
        onError: {
          target: 'reporting', 
          cond: retryLessThan3,
          target: '#hosting',
          actions: assign((context) => { return { ...context, retry: context.retry + 1 } }),
        }
      }
    },
    fail: {
      type: 'final',
      data: {type: 'failed'}
    },
    finish: {
      type: 'final',
      data: {type: 'hosting ended'}
    },
  }
}, {
  services: {
    connect_to_attestor: new Promise((resolve, reject) => { setTimeout(() => { resolve('connected') }, 3000) }),
    connect_to_lead_attestors: new Promise((resolve, reject) => { setTimeout(() => { resolve('connected') }, 3000) }),
    get_last_saved_state: new Promise((resolve, reject) => { setTimeout(() => { resolve('synced') }, 3000) }),
    receive_and_store_data_from_attestor: new Promise((resolve, reject) => { setTimeout(() => { resolve('stored') }, 3000) }),
    leave_swarm: new Promise((resolve, reject) => { setTimeout(() => { resolve('stored') }, 3000) }),
    join_swarm: new Promise((resolve, reject) => { setTimeout(() => { resolve('stored') }, 3000) }),
    delete_data_and_leave_swarm: new Promise((resolve, reject) => { setTimeout(() => { resolve('stored') }, 3000) }),
    send_proofs: new Promise((resolve, reject) => { setTimeout(() => { resolve('stored') }, 3000) }),
    report_to_chain: new Promise((resolve, reject) => { setTimeout(() => { resolve('stored') }, 3000) }),
    report_about_swarm_activity: new Promise((resolve, reject) => { setTimeout(() => { resolve('stored') }, 3000) }),
  },
})