const XState = require('xstate')
const { Machine, assign, spawn, send, sendParent } = XState

module.exports = Machine({
  initial: 'connecting',
  states: {
    connecting: {
      invoke: {
        id: 'connect', src: 'connect_to_attestor',
        onDone: {
          target: 'syncing',
          actions: (context, event) => console.log('host-sm:', event.data)
        },
        onError: {
          target: 'fail',
          actions: (context, event) => console.log('host-sm:', event.data)
        }
      },
    },
    syncing: {
      invoke: {
        id: 'sync', src: 'get_last_saved_state',
        onDone: {
          target: 'storing',
          actions: (context, event) => console.log('host-sm:', event.data)
        },
        onError: {
          target: 'fail',
          actions: (context, event) => console.log('host-sm:', event.data)
        }
      },
    },
    storing: {
      invoke: {
        id: 'sync', src: 'receive_and_store_data_from_attestor',
        onDone: {
          target: 'hosting',
          actions: (context, event) => console.log('host-sm:', event.data)
        },
        onError: {
          target: 'fail',
          actions: (context, event) => console.log('host-sm:', event.data)
        }
      },
    },
    hosting: {
      id: 'hosting',
      entry: () => console.log('host-sm: active hosting_state') ,
      on: {
        STORAGE_PROOF: {
          target: 'providing_storage_proofs',
        },
        PERFORMANCE_CHECK: {
          target: 'reporting_performance',
        },
        HOSTING_PAUSE: {
          target: 'pausing',
        },
        HOSTING_RESUME: {
          target: 'resuming',
        },
        HOSTING_END: {
          target: 'ending',
        },
      },
    },
    providing_storage_proofs: {
      initial: 'connecting',
      states: {
        connecting: {
          invoke: {
            id: 'connect_to_provide_proof', src: 'connect_to_attestor',
            onDone: {
              target: 'sending_proofs',
              actions: (context, event) => console.log('host-sm:', event.data)
            },
            onError: {
              target: '#hosting',
              actions: (context, event) => console.log('host-sm:', event.data)
            }
          }
        },
        sending_proofs: {
          invoke: {
            id: 'proof', src: 'send_proofs',
            onDone: {
              target: '#hosting',
              actions: (context, event) => console.log('host-sm:', event.data)
            },
            onError: {
              target: '#hosting',
              actions: (context, event) => console.log('host-sm:', event.data)
            }
          }
        }
      }
    },
    reporting_performance: {
      initial: 'connecting',
      states: {
        connecting: {
          invoke: {
            id: 'connect_to_lead_attestors', src: 'connect_to_lead_attestors',
            onDone: {
              target: 'sending_reports',
              actions: (context, event) => console.log('host-sm:', event.data)
            },
            onError: {
              target: '#hosting',
              actions: (context, event) => console.log('host-sm:', event.data)
            }
          }
        },
        sending_reports: {
          invoke: {
            id: 'report', src: 'report_about_swarm_activity',
            onDone: {
              target: '#hosting',
              actions: (context, event) => console.log('host-sm:', event.data)
            },
            onError: {
              target: '#hosting',
              actions: (context, event) => console.log('host-sm:', event.data)
            }
          }
        }
      }
    },
    pausing: {
      invoke: {
        id: 'pause', src: 'leave_swarm',
        onDone: {
          target: 'reporting',
          actions: (context, event) => console.log('host-sm:', event.data)
        },
        onError: {
          target: 'reporting',
          actions: (context, event) => console.log('host-sm:', event.data)
        }
      },
    },
    resuming: {
      invoke: {
        id: 'resume', src: 'join_swarm',
        onDone: {
          target: 'reporting',
          actions: (context, event) => console.log('host-sm:', event.data)
        },
        onError: {
          target: 'reporting',
          actions: (context, event) => console.log('host-sm:', event.data)
        }
      },
    },
    ending: {
      invoke: {
        id: 'end', src: 'delete_data_and_leave_swarm',
        onDone: {
          target: 'finish',
          actions: (context, event) => console.log('host-sm:', event.data)
        },
        onError: {
          // TODO
          // what happens if you fail to end hosting
          // should you leave hosting state and we add onExit: endHosting?
          // or do we run a cleanup of all unsuccessful things 
          // every once in a while?
          target: 'fail',
          actions: (context, event) => console.log('host-sm:', event.data)
        }
      },
    },
    reporting: {
      invoke: {
        id: 'report', src: 'report_to_chain',
        onDone: {
          target: '#hosting',
          actions: (context, event) => console.log('host-sm:', event.data)
        },
        onError: {
          target: '#hosting',
          actions: (context, event) => console.log('host-sm:', event.data)
        }
      }
    },
    fail: {
      type: 'final',
      data: {type: 'failed'}
    },
    finish: {
      type: 'final',
      data: {type: 'hosting ended'}
    },
  }
}, {
  services: {
    connect_to_attestor: new Promise((resolve, reject) => { setTimeout(() => { resolve('connected') }, 3000) }),
    connect_to_lead_attestors: new Promise((resolve, reject) => { setTimeout(() => { resolve('connected') }, 3000) }),
    get_last_saved_state: new Promise((resolve, reject) => { setTimeout(() => { resolve('synced') }, 3000) }),
    receive_and_store_data_from_attestor: new Promise((resolve, reject) => { setTimeout(() => { resolve('stored') }, 3000) }),
    leave_swarm: new Promise((resolve, reject) => { setTimeout(() => { resolve('swarm left') }, 3000) }),
    join_swarm: new Promise((resolve, reject) => { setTimeout(() => { resolve('swarm joined') }, 3000) }),
    delete_data_and_leave_swarm: new Promise((resolve, reject) => { setTimeout(() => { resolve('data deleted') }, 3000) }),
    send_proofs: new Promise((resolve, reject) => { setTimeout(() => { resolve('proof sent') }, 3000) }),
    report_to_chain: new Promise((resolve, reject) => { setTimeout(() => { resolve('report sent') }, 3000) }),
    report_about_swarm_activity: new Promise((resolve, reject) => { setTimeout(() => { resolve('report sent') }, 3000) }),
  },
})